generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AbilityType {
  FIRE
  ICE
  EARTH
  WATER
  ELECTRIC
  SOLAR
  LUNAR
  SHADOW
  MYSTIC
  NATURE
  ASTRAL
  TOXIC
  METALLIC
  SPECTRAL
  CHAOS
  CRISPIES
  // Add more types as needed
}

enum AbilityCategory {
  ATTACK
  DEFENSE
  UTILITY
  // Categories to describe what the ability does
}

enum EffectType {
  DAMAGE
  HEALING
  PROTECTION
  // More effect types as required
}

model monster {
  id            String         @id @default(uuid())
  capturedAt    DateTime       @default(now())
  type          String
  species       String
  rarity        String
  name          String
  status        String
  url           String
  hp            Int
  ap            Int
  menageries    menagerie[]     // Monsters are associated with the menagerie
  shop          shop[]
}

// Ability model
model Ability {
  id          Int    @unique @default(autoincrement())
  name        String
  type        String    // Enum could be used here for ability types: "Pyro", "Hydro", etc.
  cost        Int
  damage      Int?      // Optional, as some abilities may not deal direct damage
  description String
  effects     Effect[]  // Array to handle multiple effects if necessary
  category    AbilityCategory  // Enum or String: "Attack", "Defense", "Utility", etc.
}

// Effect model
model Effect {
  id          Int  @id @default(autoincrement())
  name        String  // e.g., "burning", "protection", etc.
  type        String  // Could be "Damage", "Healing", "Protection", etc.
  turns       Int     // Duration of the effect
  chance      Int     // Chance for the effect to apply (0-100%)
  damage      Int?    // Optional, used if the effect deals damage
  reduction   Int?    // Optional, for effects that reduce damage
  heal        Int?    // Optional, for effects that heal
  ability    Ability  @relation(fields: [abilityId], references: [id])
  abilityId  Int   // Foreign key to link back to Ability
}

model account {
  id            Int            @id @default(autoincrement())
  username      String         @unique
  password      String
  role          String         @default("BASIC_USER")
  createdAt     DateTime       @default(now())
  currency      Int            @default(100000)
  inventory     inventory[]    // Relation to inventory model
  menagerie     menagerie[]    // Relation to the new menagerie model
  shopItems     shop[]
}

model inventory {
  id            Int            @id @default(autoincrement())
  user          account        @relation(fields: [userId], references: [id])
  userId        Int
  // Removed the relation to monster since monsters will only go into the menagerie.
  // You can add more fields to the inventory model as needed, such as item type, quantity, or description.
}

model menagerie {
  id            Int            @id @default(autoincrement())
  user          account        @relation(fields: [userId], references: [id])
  userId        Int
  monster       monster        @relation(fields: [monsterId], references: [id])
  monsterId     String
  // Additional fields for menagerie management can be added here
}

model shop {
  id            String         @id @default(uuid())
  monsterId     String
  playerId      Int

  price         Int
  monster       monster        @relation(fields: [monsterId], references: [id])
  player        account        @relation(fields: [playerId], references: [id])

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}
