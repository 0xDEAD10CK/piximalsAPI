generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AbilityType {
  FIRE
  ICE
  EARTH
  WATER
  ELECTRIC
  SOLAR
  LUNAR
  SHADOW
  MYSTIC
  NATURE
  ASTRAL
  TOXIC
  METALLIC
  SPECTRAL
  CHAOS
  CRISPIES
  // Add more types as needed
}

enum AbilityCategory {
  ATTACK
  DEFENSE
  UTILITY
  // Categories to describe what the ability does
}

enum EffectType {
  DAMAGE
  HEALING
  PROTECTION
  BUFF
  DEBUFF
  // More effect types as required
}



model Monster {
  id            String         @id @default(uuid())
  capturedAt    DateTime       @default(now())
  type          String
  species       String
  rarity        String
  name          String
  status        String
  url           String
  hp            Int
  ap            Int
  abilities     Ability[]       // Monster abilities
  menageries    Menagerie[]     // Monsters are associated with the menagerie
  shop          Shop[]
  zone          Zone[]          // Monsters can spawn in multiple zones
}

// Ability model
model Ability {
  id              Int        @id @default(autoincrement())
  name            String
  type            String      // e.g., "Pyro", "Hydro", etc., or use an Enum for stricter control
  cost            Int         // Mana or energy cost to use the ability
  damage          Int?        // Base damage of the ability, optional for non-damaging abilities
  description     String      // Description of the ability's effect or flavor text
  category        String      // "Attack", "Defense", "Utility", etc., or use an Enum

  // Prefixed effect-related fields
  effectType      String?     // Type of effect: "Damage", "Healing", "Protection", etc.
  effectTurns     Int?        // Duration of the effect in turns
  effectChance    Int?        // Chance for the effect to apply (0-100%)
  effectDamage    Int?        // Optional, used if the effect deals damage
  effectReduction Int?        // Optional, for effects that reduce damage or stats
  effectHeal      Int?        // Optional, for effects that heal the target
  effectIncrease  Int?        // Optional, for buffs that increase stats or effects

  monsters        Monster[]   // Abilities can be associated with multiple monsters
}

model Account {
  id              Int            @id @default(autoincrement())
  username        String         @unique
  password        String
  role            String         @default("BASIC_USER")
  createdAt       DateTime       @default(now())
  currency        Int            @default(100000)
  level           Int            @default(1)
  experience      Int            @default(0)
  health          Int            @default(100)
  starter         Boolean        @default(false)

  locationId    Int           
  location      Location       @relation(fields: [locationId], references: [id])
  zoneId        String?
  zone          Zone?           @relation(fields: [zoneId], references: [id])// Relation to the zone model

  inventory       Inventory?    // Relation to inventory model
  menagerie       Menagerie[]    // Relation to the new menagerie model
  shopItems       Shop[]
  quests          Quest[] 

  // Equippable slots linked to InventoryItem for consistency
  equippedWeapon  InventoryItem?  @relation("equippedWeapon", fields: [equippedWeaponId], references: [id])
  equippedHead    InventoryItem?  @relation("equippedHead", fields: [equippedHeadId], references: [id])
  equippedBody    InventoryItem?  @relation("equippedBody", fields: [equippedBodyId], references: [id])
  equippedHands   InventoryItem?  @relation("equippedHands", fields: [equippedHandsId], references: [id])
  equippedFeet    InventoryItem?  @relation("equippedFeet", fields: [equippedFeetId], references: [id])
  equippedLegs    InventoryItem?  @relation("equippedLegs", fields: [equippedLegsId], references: [id])

  // Foreign key fields with unique constraints
  equippedWeaponId Int?           @unique
  equippedHeadId   Int?           @unique
  equippedBodyId   Int?           @unique
  equippedHandsId  Int?           @unique
  equippedFeetId   Int?           @unique
  equippedLegsId   Int?           @unique
}

model Item {
  id            Int             @id @default(autoincrement())
  name          String
  rarity        String
  type          String          // "Hands", "Weapon", "Buff", etc.
  effects       Json?            // JSON field to store effects flexibly
  buyPrice      Int
  sellPrice     Int
  // No direct relation to Inventory; handled through an intermediary or other contexts.
  zone          Zone[]          // Items can be found in multiple zones
  InventoryItem InventoryItem[]
}

model Inventory {
  id            Int             @id @default(autoincrement())
  user          Account         @relation(fields: [userId], references: [id])
  userId        Int             @unique
  items         InventoryItem[] // Relation to InventoryItem model
}

model InventoryItem {
  id            Int             @id @default(autoincrement())
  inventory     Inventory       @relation(fields: [inventoryId], references: [id])
  inventoryId   Int
  item          Item            @relation(fields: [itemId], references: [id])
  itemId        Int
  quantity      Int             @default(1) // Optional: For stackable items

  // Optional relations back to Account for equippable slots
  accountsEquippedWeapon  Account? @relation("equippedWeapon")
  accountsEquippedHead    Account? @relation("equippedHead")
  accountsEquippedBody    Account? @relation("equippedBody")
  accountsEquippedHands   Account? @relation("equippedHands")
  accountsEquippedFeet    Account? @relation("equippedFeet")
  accountsEquippedLegs    Account? @relation("equippedLegs")
}

model Menagerie {
  id            Int            @id @default(autoincrement())
  user          Account        @relation(fields: [userId], references: [id])
  userId        Int
  monster       Monster        @relation(fields: [monsterId], references: [id])
  monsterId     String
  // Additional fields for menagerie management can be added here
}

model Shop {
  id            String         @id @default(uuid())
  monsterId     String
  playerId      Int

  price         Int
  monster       Monster        @relation(fields: [monsterId], references: [id])
  player        Account        @relation(fields: [playerId], references: [id])

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model Zone {
  id            String         @id @default(uuid())
  zonename      String    
  monsters      Monster[]      // One-to-many relationship with Monster
  players       Account[]     // One-to-many relationship with Account
  type          String       // Type of zone, e.g. forest, desert, etc. inherited from the location model
  description   String
  items         Item[]        // One-to-many relationship with Item
}

model Location {
  id            Int         @id @default(autoincrement())
  name          String
  playerId      Int[] //multiple players can be at a location
  zoneId        String[]
  players       Account[]      // One-to-many relationship with Account
  type          String
  description   String
  rarity        Json[]
  quests        Quest[] 
}

model Quest {
  id           Int        @id @default(autoincrement())
  title        String
  description  String
  playerId     Int         // Foreign key for Account
  locationId   Int         // Foreign key for Location
  completed    Boolean    @default(false)
  reward       Int
  typeofQuest  QuestType

  player       Account     @relation(fields: [playerId], references: [id])   // Relation to Account
  location     Location    @relation(fields: [locationId], references: [id]) // Relation to Location
}

enum QuestType {
  CAPTURE
  DEFEAT
  COLLECT
}